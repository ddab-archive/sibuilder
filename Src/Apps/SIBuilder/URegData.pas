{ ##
  @PROJECT_NAME             SI Tools
  @PROJECT_DESC             Simple program installation tools - project manager
                            and creator with installation and un-installation
                            programs.
  @FILE                     URegData.pas
  @COMMENTS                 This is one of the units that together define
                            classes that model an installation project. This
                            unit defines the TRegData and TRegDataList classes.
                            The latter class manages a list of user-defined
                            registry values while TRegData provides the
                            properties and methods required to manage the values
                            themselves.
  @HISTORY(
    @REVISION(
      @VERSION              1.0
      @DATE                 09/03/2000
      @COMMENTS             Original version.
    )
    @REVISION(
      @VERSION              2.0
      @DATE                 28/08/2000
      @COMMENTS             This unit's classes now read/write their properties
                            from/to XML objects rather than direct to binary
                            streams. The project file saving/loading behaviour
                            has been separated from the installation data file
                            creation process. Because of this methods enabling
                            the installation information required by the install
                            library to be written to an XML file have been
                            added. Since the classes are no longer used by the
                            install/uninstall programs all registry update
                            functionality has been removed from the classes.\
                            Other changes were:
                            + Extra long error messages generated by attempting
                              to convert long binary values to integers were
                              trapped and shortened.
                            + Unused TRegData.GetPath and TRegData.GetRootKey
                              property access overrides were removed.
                            + Added method to directly set the data buffer to a
                              binary value.
                            + Added class method to return the max data size
                              allowed to be written to registry.
    )
    @REVISION(
      @VERSION              2.1
      @DATE                 24/12/2000
      @COMMENTS             + Added new ExpandMacroPaths property & facilities
                              to read/write from XML files.
                            + Made all error message string literals with
                              resource strings.
    )
    @REVISION(
      @VERSION              2.2
      @DATE                 29/12/2002
      @COMMENTS             Changed binary parsing and binary to string methods
                            to use routines from new UBinStrings unit to perform
                            conversions, rather than doing them natively in the
                            TRegData class. The string to binary conversion is
                            now more flexible about the input format.
    )
    @REVISION(
      @VERSION              2.3
      @DATE                 28/11/2003
      @COMMENTS             Refactoring: Deleted references to unused units.
    )
  )
}


{
 * ***** BEGIN LICENSE BLOCK *****
 * 
 * Version: MPL 1.1
 * 
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with the
 * License. You may obtain a copy of the License at http://www.mozilla.org/MPL/
 * 
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License for
 * the specific language governing rights and limitations under the License.
 * 
 * The Original Code is URegData.pas.
 * 
 * The Initial Developer of the Original Code is Peter Johnson
 * (http://www.delphidabbler.com/).
 * 
 * Portions created by the Initial Developer are Copyright (C) 2000-2003 Peter
 * Johnson. All Rights Reserved.
 * 
 * ***** END LICENSE BLOCK *****
}


unit URegData;


interface


uses
  // Delphi
  SysUtils, Registry,
  // Project
  URegObjects, UXMLTag;

type

  {
  ERegData:
    Class of exception raised by TRegData.

    Inheritance: ERegData -> [Exception]
  }
  ERegData = class(Exception);

  {
  ERegDataList:
    Class of exception raised by TRegDataList.

    Inheritance: ERegDataList -> [Exception]
  }
  ERegDataList = class(Exception);

  {
  TRegData:
    Class that encapsulates a registry data item and provides the methods
    required to associate values of various types with identifiers and to store
    the information in XML format.

    Inheritance: TRegData -> TRegObject -> TXMLObjectItem -> TObjListItem
      -> [TObject]
  }
  TRegData = class(TRegObject)
  private // properties
    fValueType: TRegDataType;
    fExpandMacroPaths: Boolean;
  private
    fDataBuffer: Pointer;
      {Pointer to buffer where the data for this item is stored}
    fDataBufferSize: Integer;
      {The current size of fDataBuffer}
    procedure AllocBuffer(const Size: Integer);
      {Allocates a buffer (pointed to by fDataBuffer) of given size}
    procedure StoreString(const Str: string);
      {Store the given string in the data buffer}
    function ReadString: string;
      {Read the string from the data buffer - this assumes that a zero
      terminated string is stored there, but performs no checking}
    function GetString: string;
      {Returns the current contents of buffer as a string provided that current
      data type is rdString, otherwise raises exception}
    procedure SetString(const AString: string);
      {Stores the given string in the data buffer and sets the current data type
      to rdString}
    function GetExpandedString: string;
      {Returns the current contents of buffer as a string provided that current
      data type is rdExpandString, otherwise raises exception}
    procedure SetExpandedString(const AString: string);
      {Stores the given string in the data buffer and sets the current data type
      to rdExpandString}
    function GetInteger: Integer;
      {Returns the current contents of the buffer as an integer providing the
      current data type is rdInteger, otherwise raises exception}
    procedure SetInteger(const AnInt: Integer);
      {Stores the given integer in the data buffer and sets the current data
      type to rdInteger}
    function GetBinaryAsString: string;
      {Return the binary data stored in the buffer as a string - the string
      comprises the hex representation of each byte, separated by a space.
      Raises exception if the current data type is not rdBinary}
    procedure ParseBinaryString(const AStr: string);
      {Parses given string (which is a representation of binary data in format
      that is returned by GetBinaryAsString method) and stores the data
      represented by the string in the data buffer with data type rdBinary.
      Raises exception if string format is not valid, or if there is too much
      data. In these cases current data type is set to rdUnknown}
    function ParseInteger(const AStr: string): Integer;
      {Converts value in given string to integer and returns it. If string is
      not a valid integer then an exception is raised}
  protected // "friend" methods for use in TRegDataList
    function HasValue: Boolean;
      {Returns true if the data item has been given a value, false if not}
  public
    constructor Create(const Name: string); override;
      {Class constructor - create data item with given name and record that
      item has no value assigned}
    destructor Destroy; override;
      {Class destructor - ensures that any data buffer that has been allocated
      is freed}
    procedure SaveProjectXML(const ParentTag: TXMLTag); override;
      {Saves project information as sub tag of given XML tag}
    procedure LoadProjectXML(const XMLTag: TXMLTag); override;
      {Sets properties according to information in given XML tag}
    procedure SaveInstallXML(const ParentTag: TXMLTag); override;
      {Saves information required to install/uninstall this registry data as a
      sub-tag of given tag}
    procedure SetBinary(var Buffer; const Size: Integer);
      {Stores Size bytes of data from given buffer in the data buffer and sets
      the current data type to rdBinary}
    procedure SetAsString(const ValueType: TRegDataType; const AStr: string);
      {Sets the data of the given data type from the given string. An exception
      is raised if value type is rdUnkown}
    function GetAsString: string;
      {Returns a string representation of value of any data type except
      rdUnknown. An exception is raised if an attempt is made to get an
      rdUnknown data type}
    property ValueType: TRegDataType read fValueType;
      {The type of the current data value}
    property ExpandMacroPaths: Boolean
      read fExpandMacroPaths write fExpandMacroPaths;
      {Flag true if macro paths are to be expanded for rdString and
      rdExpandString data types: ignored if data is not one of these types}
    class function MaxDataSize: Integer;
      {Returns the maximum size of data we allow to be written to registry}
  end;

  {
  TRegDataList:
    Maintains a list of TRegData objects and cuases them to be validated and
    installed / uninstalled in the Registry.

    Inheritance: TRegDataList -> TRegObjList -> TXMLObjectList -> TObjList
      -> [TObject]
  }
  TRegDataList = class(TRegObjList)
  private // properties
    function GetItem(AnIndex: Integer): TRegData;
  public
    constructor Create(Owner: TObject); override;
      {Class constructor - creates a list of TRegData objects}
    procedure Validate;
      {Checks that all registry data items in list have valid values. Returns
      normally if everything is OK and raises ERegDataList exception if an error
      is found}
    property Items[AnIndex: Integer]: TRegData read GetItem;
      {The RegData objects in the list as an array}
  end;


implementation


uses
  // Delphi
  Windows,
  // Project
  UBinStrings;


resourcestring
  // Error messages
  sIntegerRequired = 'Registry data type of "%s" is not Integer';
  sExpStringRequired = 'Registry data type of "%s" is not Expanded String';
  sStringRequired = 'Registry data type of "%s" is not String';
  sBadBinaryString = 'Invalid binary data definition string';
  sBadInteger = 'Invalid integer value';
  sDataTooBig = 'Data for "%s" must not exceed %d in size';
  sMissingValue = 'No value set for "%s"';
  sCantSetUnknown = 'Can''t set a value for an Unknown data type';

const
  // Maximum size of data we allow to be installed in registry
  cBinarySizeLimit = 2048;


{ TRegData }

procedure TRegData.AllocBuffer(const Size: Integer);
  {Allocates a buffer (pointed to by fDataBuffer) of given size}
begin
  // Check if requested size is greater than max allowed - raise exception if so
  if Size > cBinarySizeLimit then
    raise ERegData.CreateFmt(sDataTooBig, [Name, cBinarySizeLimit]);
  // Check if we've already allocated a buffer in fDataBuffer, and free it if so
  if fDataBufferSize > 0 then
    FreeMem(fDataBuffer, fDataBufferSize);
  // Now allocate the buffer of requested size, and store the size
  GetMem(fDataBuffer, Size);
  fDataBufferSize := Size;
end;

constructor TRegData.Create(const Name: string);
  {Class constructor - create data item with given name and record that item has
  no value assigned}
begin
  inherited Create(Name);
  fValueType := rdUnknown;
end;

destructor TRegData.Destroy;
  {Class destructor - ensures that any data buffer that has been allocated is
  freed}
begin
  if fDataBufferSize > 0 then
    FreeMem(fDataBuffer, fDataBufferSize);
  inherited Destroy;
end;

function TRegData.GetAsString: string;
  {Returns a string representation of value of any data type except rdUnknown.
  An exception is raised if an attempt is made to get an rdUnknown data type}
begin
  case fValueType of
    rdUnknown: raise ERegData.CreateFmt(sMissingValue, [Name]);
    rdString: Result := GetString;
    rdExpandString: Result := GetExpandedString;
    rdInteger: Result := IntToStr(GetInteger);
    rdBinary: Result := GetBinaryAsString;
  end;
end;

function TRegData.GetBinaryAsString: string;
  {Return the binary data stored in the buffer as a string - the string
  comprises the hex representation of each byte, separated by a space. Raises
  exception if the current data type is not rdBinary}
begin
  // We should only call this method when buffer contains binary data
  Assert(fValueType = rdBinary);
  // Perform conversion and return the result
  Result := UBinStrings.BinaryToSpaceBinStr(fDataBuffer, fDataBufferSize);
end;

function TRegData.GetExpandedString: string;
  {Returns the current contents of buffer as a string provided that current data
  type is rdExpandString, otherwise raises exception}
begin
  if fValueType <> rdExpandString then
    raise ERegData.CreateFmt(sExpStringRequired, [Name]);
  Result := ReadString;
end;

function TRegData.GetInteger: Integer;
  {Returns the current contents of the buffer as an integer providing the
  current data type is rdInteger, otherwise raises exception}
var
  PInteger: ^Integer;   // pointer to integer in data buffer
begin
  // Check that we have an integer type
  if fValueType <> rdInteger then
    raise ERegData.CreateFmt(sIntegerRequired, [Name]);
  // Make pointer to integer address data buffer
  PInteger := fDataBuffer;
  // Return the integer
  Result := PInteger^;
end;

function TRegData.GetString: string;
  {Returns the current contents of buffer as a string provided that current data
  type is rdString, otherwise raises exception}
begin
  if fValueType <> rdString then
    raise ERegData.CreateFmt(sStringRequired, [Name]);
  Result := ReadString;
end;

function TRegData.HasValue: Boolean;
  {Returns true if the data item has been given a value, false if not}
begin
  Result := (fValueType <> rdUnknown);
end;

procedure TRegData.LoadProjectXML(const XMLTag: TXMLTag);
  {Sets properties according to information in given XML tag}
begin
  // Record properties from params
  Name := XMLTag.Params['name'];
  fValueType := TRegDataType(XMLTag.ParamAsInt['type']);
  fExpandMacroPaths := Boolean(XMLTag.ParamAsInt['expmacros']);
  if fValueType <> rdUnknown then
    // Read data into buffer from tag's text if type is not unknown
    SetAsString(fValueType, XMLTag.PlainText);
end;

class function TRegData.MaxDataSize: Integer;
  {Returns the maximum size of data we allow to be written to registry}
begin
  Result := cBinarySizeLimit;
end;

procedure TRegData.ParseBinaryString(const AStr: string);
  {Parses given string (which is a representation of binary data in format that
  is returned by GetBinaryAsString method) and stores the data represented by
  the string in the data buffer with data type rdBinary. Raises exception if
  string format is not valid, or if there is too much data. In these cases
  current data type is set to rdUnknown}
var
  BinBuffer: PByte;       // buffer allocated to store binary
  BinBufferSize: Integer; // the size of the above buffer
begin
  // Record that we have an unknown data type - this will be so if parsing fails
  fValueType := rdUnknown;
  try
    UBinStrings.SpaceBinStrToBinary(AStr, BinBuffer, BinBufferSize);
    // Check if requested size within max allowed
    if BinBufferSize <= cBinarySizeLimit then
    begin
      // Buffer size is within limits: we free any existing internal buffer and
      // update it to point to new buffer allocated by SpaceBinStrToBinary
      if fDataBufferSize > 0 then
        FreeMem(fDataBuffer, fDataBufferSize);
      fDataBuffer := BinBuffer;
      fDataBufferSize := BinBufferSize;
      // record that current value type is binary
      fValueType := rdBinary;
    end
    else
    begin
      // Buffer is too large: free buffer allocated by SpaceBinStrToBinary and
      // raise exception
      FreeMem(BinBuffer, BinBufferSize);
      raise ERegData.CreateFmt(sDataTooBig, [Name, cBinarySizeLimit]);
    end;
  except
    // Convert any exception raised in SpaceBinStrToBinary to ERegData exception
    on E: EBinStrings do
      raise ERegData.Create(sBadBinaryString);
  end;
end;

function TRegData.ParseInteger(const AStr: string): Integer;
  {Converts value in given string to integer and returns it. If string is not a
  valid integer then an exception is raised}
begin
  try
    // Attempt to convert string to integer
    Result := StrToInt(AStr);
  except
    on E: EConvertError do
      // There was a conversion error - create own exception with same message
      raise ERegData.Create(sBadInteger);
  end;
end;

function TRegData.ReadString: string;
  {Read the string from the data buffer - this assumes that a zero terminated
  string is stored there but performs no checking}
begin
  Result := StrPas(fDataBuffer);
end;

procedure TRegData.SaveInstallXML(const ParentTag: TXMLTag);
  {Saves information required to install/uninstall this registry data as a sub-
  tag of given tag}
var
  Tag: TXMLTag;     // the XML tag where registry data info is to be stored
begin
  // Create required sub tag
  Tag := ParentTag.AddSubTag('regdata');
  // Store property informaton in tag
  Tag.Params['name'] := Name;
  Tag.ParamAsInt['type'] := Ord(fValueType);
  if fExpandMacroPaths then   // only write 'expmacros' if flag is true
    Tag.ParamAsInt['expmacros'] := Ord(fExpandMacroPaths);
  if fValueType <> rdUnknown then
    // Store value as tag's text if data type is not unknown
    Tag.PlainText := GetAsString;
end;

procedure TRegData.SaveProjectXML(const ParentTag: TXMLTag);
  {Saves project information as sub tag of given XML tag}
var
  Tag: TXMLTag;   // tag where group object is stored
begin
  // Create required tag
  Tag := ParentTag.AddSubTag('regdata');
  // Store properties as parameters of tag
  Tag.Params['name'] := Name;
  Tag.ParamAsInt['type'] := Ord(fValueType);
  Tag.ParamAsInt['expmacros'] := Ord(fExpandMacroPaths);
  // Store value as tag's string, if value type is not unknown
  if fValueType <> rdUnknown then
    Tag.PlainText := GetAsString;
end;

procedure TRegData.SetAsString(const ValueType: TRegDataType;
  const AStr: string);
    {Sets the data of the given data type from the given string. An exception is
    raised if value type is rdUnkown}
begin
  // How we set the value depends on data type
  case ValueType of
    rdUnknown:
      // Unknown data type not allowed - raise exception
      raise ERegData.Create(sCantSetUnknown);
    rdString:
      // String type - store the string
      SetString(AStr);
    rdExpandString:
      // Expanded string type - store the string
      SetExpandedString(AStr);
    rdInteger:
      // Integer type - convert string to integer and store it
      SetInteger(ParseInteger(AStr));
    rdBinary:
      // Binary type - parse the string representation and store the binary code
      // it represents
      ParseBinaryString(AStr);
  end;
end;

procedure TRegData.SetBinary(var Buffer; const Size: Integer);
  {Stores Size bytes of data from given buffer in the data buffer and sets the
  current data type to rdBinary}
begin
  AllocBuffer(Size);
  Move(Buffer, fDataBuffer^, Size);
  fValueType := rdBinary;
end;

procedure TRegData.SetExpandedString(const AString: string);
  {Stores the given string in the data buffer and sets the current data type to
  rdExpandString}
begin
  // Set unknown data type in case an exception is raised
  fValueType := rdUnknown;
  // Now store the string in the buffer
  StoreString(AString);
  // To get here we succeeded so set current data type to rdExpandString
  fValueType := rdExpandString;
end;

procedure TRegData.SetInteger(const AnInt: Integer);
  {Stores the given integer in the data buffer and sets the current data type to
  rdInteger}
begin
  // Set unknown data type in case an exception is raised
  fValueType := rdUnknown;
  // Allocate a buffer to store integer, and store it
  AllocBuffer(SizeOf(Integer));
  Move(AnInt, fDataBuffer^, SizeOf(Integer));
  // If we get here we've succeeded - record that data type is rdInteger
  fValueType := rdInteger;
end;

procedure TRegData.SetString(const AString: string);
  {Stores the given string in the data buffer and sets the current data type to
  rdString}
begin
  // Set unknown data type in case an exception is raised
  fValueType := rdUnknown;
  // Now store the string in the buffer
  StoreString(AString);
  // To get here we succeeded so set current data type to rdString
  fValueType := rdString;
end;

procedure TRegData.StoreString(const Str: string);
  {Store the given string in the data buffer}
begin
  // Allocate a buffer large enough for string (with terminating zero)
  AllocBuffer(Length(Str) + 1);
  // Copy the string into the buffer
  StrPCopy(fDataBuffer, Str);
end;


{ TRegDataList }

constructor TRegDataList.Create(Owner: TObject);
  {Class constructor - creates a list of TRegData objects}
begin
  inherited CreateForClass(Owner, TRegData);
end;

function TRegDataList.GetItem(AnIndex: Integer): TRegData;
  {Read access method for Items property}
begin
  Result := inherited GetItem(AnIndex) as TRegData;
end;

procedure TRegDataList.Validate;
  {Checks that all registry data items in list have valid values. Returns
  normally if everything is OK and raises ERegDataList exception if an error is
  found}
var
  I: Integer;   // loops thru all registry values
begin
  // loop thru all registry values and return exception if any of them have no
  // value assigned
  for I := 0 to Count - 1 do
  begin
    if not GetItem(I).HasValue then
      raise ERegDataList.Create(GetItem(I).Name);
  end;
end;

end.
